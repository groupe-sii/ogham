<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="fr"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>MessagingBuilder.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">reporting</a> &gt; <a href="../index.html" class="el_bundle">ogham-core</a> &gt; <a href="index.source.html" class="el_package">fr.sii.ogham.core.builder</a> &gt; <span class="el_source">MessagingBuilder.java</span></div><h1>MessagingBuilder.java</h1><pre class="source lang-java linenums">package fr.sii.ogham.core.builder;

import static java.util.Arrays.asList;

import java.io.InputStream;
import java.nio.file.Files;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Properties;
import java.util.Set;

import javax.activation.MimetypesFileTypeMap;

import org.reflections.Reflections;
import org.reflections.scanners.SubTypesScanner;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import fr.sii.ogham.core.builder.configurer.ConfigurerFor;
import fr.sii.ogham.core.builder.configurer.MessagingConfigurer;
import fr.sii.ogham.core.builder.env.EnvironmentBuilder;
import fr.sii.ogham.core.builder.env.SimpleEnvironmentBuilder;
import fr.sii.ogham.core.builder.mimetype.MimetypeDetectionBuilder;
import fr.sii.ogham.core.builder.mimetype.SimpleMimetypeDetectionBuilder;
import fr.sii.ogham.core.builder.resolution.ResourceResolutionBuilder;
import fr.sii.ogham.core.builder.resolution.StandaloneResourceResolutionBuilder;
import fr.sii.ogham.core.exception.MessagingException;
import fr.sii.ogham.core.exception.builder.BuildException;
import fr.sii.ogham.core.sender.ConditionalSender;
import fr.sii.ogham.core.service.EverySupportingMessagingService;
import fr.sii.ogham.core.service.MessagingService;
import fr.sii.ogham.core.service.WrapExceptionMessagingService;
import fr.sii.ogham.email.builder.EmailBuilder;
import fr.sii.ogham.email.message.Email;
import fr.sii.ogham.sms.builder.SmsBuilder;
import fr.sii.ogham.sms.message.Sms;

/**
 * Ogham provides many useful behaviors to focus on the message content and not
 * the need of understanding and implementing complex protocols. Sending emails
 * seems to be easy but the RFCs
 * (&lt;a href=&quot;https://tools.ietf.org/html/rfc5321&quot;&gt;RFC5321&lt;/a&gt;,
 * &lt;a href=&quot;https://tools.ietf.org/html/rfc821&quot;&gt;RFC821&lt;/a&gt;, ...) are long and
 * complex. If you don't know those RFCs, some email clients won't be able to
 * read your emails. This is the same with the
 * &lt;a href=&quot;http://opensmpp.org/specs/smppv50.pdf&quot;&gt;SMPP protocol&lt;/a&gt; used for
 * sending SMS.
 * 
 * The builder is a helper to instantiate and configure a
 * {@link MessagingService}. The {@link MessagingService} is used to send:
 * &lt;ul&gt;
 * &lt;li&gt;{@link Email} messages&lt;/li&gt;
 * &lt;li&gt;{@link Sms} messages&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * Content of the messages can be provided by templates. Templates are parsed by
 * template engines. Several template engines are supported:
 * &lt;ul&gt;
 * &lt;li&gt;Thymeleaf&lt;/li&gt;
 * &lt;li&gt;Freemaker&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * Ogham allows to send {@link Email} and {@link Sms} using several
 * implementations:
 * &lt;ul&gt;
 * &lt;li&gt;JavaMail (STMP) or SendGrid (HTTP) for sending {@link Email}&lt;/li&gt;
 * &lt;li&gt;Cloudhopper (SMPP) or OVH (HTTP) for sending {@link Sms}&lt;/li&gt;
 * &lt;/ul&gt;
 * The aim is to provide an abstraction to construct a portable message (
 * {@link Email} or {@link Sms}) and to be able to change infrastructure (SMTP
 * server to online HTTP service for example) without changing your code.
 * 
 * &lt;p&gt;
 * Here is an example of standard configuration that provides a default behavior
 * that fits 95% of usages:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * // Instantiate the messaging service
 * MessagingService service = MessagingBuilder.standard()
 *   .build();
 * // send the email
 * service.send(new Email()
 *   .content(new MultiTemplateContent(&quot;email/sample&quot;, new SampleBean(&quot;foo&quot;, 42)))
 *   .to(&quot;Foo Bar &amp;lt;foo.bar@sii.fr&amp;gt;&quot;))
 *   .attach(new Attachment(&quot;file:/data/reports/report1.pdf&quot;));
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * This sample shows that:
 * &lt;ul&gt;
 * &lt;li&gt;System properties are used to configure &quot;mail.host&quot; and &quot;mail.port&quot;&lt;/li&gt;
 * &lt;li&gt;As properties &quot;mail.host&quot; and &quot;mail.port&quot; are defined and
 * &quot;ogham-email-javamail&quot; is used, the email is sent using JavaMail
 * implementation&lt;/li&gt;
 * &lt;li&gt;An email is sent to &quot;foo.bar@sii.fr&quot;&lt;/li&gt;
 * &lt;li&gt;The email provides a main content (HTML) and a fallback content (text)
 * &lt;ul&gt;
 * &lt;li&gt;The HTML content comes from a template located in the classpath
 * (email/sample.html) and variables that are present in the template are
 * replaced by values provided by a simple bean object (no conversion is
 * needed). As &quot;ogham-template-thymeleaf&quot; is used and the template is a
 * Thymeleaf template (Thymeleaf directive on &amp;lt;html&amp;gt; tag), this template
 * is parse by Thymeleaf&lt;/li&gt;
 * &lt;li&gt;The text content comes from a template located in the classpath
 * (email/sample.txt.ftl) and variables that are present in the template are
 * replaced by values provided by a simple bean object (no conversion is
 * needed). As &quot;ogham-template-freemarker&quot; is used and the template is a
 * Freemarker template (&quot;.ftl&quot; extension), this template is parse by
 * Thymeleaf&lt;/li&gt;
 * &lt;/ul&gt;
 * &lt;/li&gt;
 * &lt;li&gt;The HTML template has CSS styles that are inlined (CSS are forbidden by
 * many email clients but inlined styles attributes are allowed)&lt;/li&gt;
 * &lt;li&gt;The HTML template references images (using &amp;lt;img&amp;gt;) that are
 * automatically attached to the sent email (mimetype of each image has been
 * detected and indicated to the sent message)&lt;/li&gt;
 * &lt;li&gt;A file located on the filesystem is attached to the email, its mimetype
 * has been automatically detected and indicated to the sent message&lt;/li&gt;
 * &lt;li&gt;The subject is provided by the &amp;lt;title&amp;gt; tag of the HTML&lt;/li&gt;
 * &lt;li&gt;The sender email address is provided by the system property
 * &quot;ogham.email.from&quot;&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * &lt;p&gt;
 * Here is an example of minimal configuration that provides same default
 * behavior as previous exemple but no sender implementation is registered. You
 * then have to enable implementation(s) and configure them:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * // Instantiate the messaging service
 * MessagingService service = MessagingBuilder.minimal()
 *   .email()
 *     .sender(JavaMailBuilder.class)
 *       .host(&quot;${mail.host}&quot;)
 *       .port(&quot;${mail.port}&quot;)
 *       .charset(&quot;${ogham.email.javamail.body.charset}&quot;, &quot;UTF-8&quot;)
 *       .mimetype()
 *         .tika()
 *           .failIfOctetStream(false)
 *           .and()
 *         .and()
 *       .and()
 *     .and()
 *   .build();
 * // send the email
 * service.send(new Email()
 *   .content(new MultiTemplateContent(&quot;email/sample&quot;, new SampleBean(&quot;foo&quot;, 42)))
 *   .to(&quot;Foo Bar &amp;lt;foo.bar@sii.fr&amp;gt;&quot;))
 *   .attach(new Attachment(&quot;file:/data/reports/report1.pdf&quot;));
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * This sample has the same effect as the previous one (for this case, some
 * options of JavaMail implementation are not enabled). Moreover, if you want to
 * send a {@link Sms}, you will also need to register and configure at least one
 * SMS sender implementation.
 * 
 * To benefit of all advantages but keeping control on which implementations are
 * use, you can register implementation configurers:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * // Instantiate the messaging service
 * MessagingService service = MessagingBuilder.minimal()
 *   .register(new DefaultJavaMailConfigurer(), 50000)     // enable sending Email through SMTP
 *   .register(new DefaultSendGridConfigurer(), 30000)     // enable sending Email through HTTP (using an online service)
 *   .register(new DefaultCloudHopperConfigurer(), 40000)  // enable sending SMS through SMPP
 *   .register(new DefaultOvhSmsConfigurer(), 20000)     // enable sending SMS through HTTP (using an online service)
 *   .build();
 * // send the email
 * service.send(new Email()
 *   .content(new MultiTemplateContent(&quot;email/sample&quot;, new SampleBean(&quot;foo&quot;, 42)))
 *   .to(&quot;Foo Bar &amp;lt;foo.bar@sii.fr&amp;gt;&quot;))
 *   .attach(new Attachment(&quot;file:/data/reports/report1.pdf&quot;));
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * This sample has the same effect as using {@link #standard()}.
 * 
 * You can create your own configurer for any sender implementation and register
 * it too. You can then mutualize and externalize reusable configuration.
 * 
 * &lt;p&gt;
 * The predefined behaviors are brought by static factory methods
 * {@link #standard()} and {@link #minimal()}. If you don't want to use
 * predefined behaviors, you can use directly {@code new MessagingBuilder()} or
 * {@link #empty()} static factory.
 * 
 * Those factory methods rely on {@link MessagingConfigurer}s to provide
 * predefined behaviors.
 * 
 * &lt;p&gt;
 * The default behaviors can be used and customized:
 * 
 * &lt;pre&gt;
 * &lt;code&gt;
 * // Instantiate the messaging service
 * MessagingService service = MessagingBuilder.standard()
 *   .environment()
 *     .properties()
 *       .set(&quot;mail.host&quot;, &quot;localhost&quot;)
 *       .set(&quot;mail.port&quot;, &quot;25&quot;)
 *       .and()
 *     .and()
 *   .mimetype()
 *     .defaultMimetype(&quot;application/octet-stream&quot;)
 *     .and()
 *   .build();
 * // send the email
 * service.send(new Email()
 *   .content(new MultiTemplateContent(&quot;email/sample&quot;, new SampleBean(&quot;foo&quot;, 42)))
 *   .to(&quot;Foo Bar &amp;lt;foo.bar@sii.fr&amp;gt;&quot;))
 *   .attach(new Attachment(&quot;file:/data/reports/report1.pdf&quot;));
 * &lt;/code&gt;
 * &lt;/pre&gt;
 * 
 * The previous sample shows how to change default behaviors to fit your needs:
 * &lt;ul&gt;
 * &lt;li&gt;It set the SMTP host and port in the code not by using system
 * properties&lt;/li&gt;
 * &lt;li&gt;It overrides default mimetype to provide a mimetype that fit your needs
 * when mimetype detection is not enough accurate&lt;/li&gt;
 * &lt;/ul&gt;
 * 
 * @author Aur√©lien Baudet
 *
 */
public class MessagingBuilder implements Builder&lt;MessagingService&gt; {
<span class="fc" id="L233">	private static final Logger LOG = LoggerFactory.getLogger(MessagingBuilder.class);</span>
	private static final String BASE_PACKAGE = &quot;fr.sii.ogham&quot;;

	private List&lt;PrioritizedConfigurer&gt; configurers;
	private EnvironmentBuilder&lt;MessagingBuilder&gt; environmentBuilder;
	private MimetypeDetectionBuilder&lt;MessagingBuilder&gt; mimetypeBuilder;
	private StandaloneResourceResolutionBuilder&lt;MessagingBuilder&gt; resourceBuilder;
	private EmailBuilder emailBuilder;
	private SmsBuilder smsBuilder;
	private boolean wrapUncaught;

	/**
	 * Initializes the builder with minimal requirements:
	 * &lt;ul&gt;
	 * &lt;li&gt;an empty {@link EnvironmentBuilder}&lt;/li&gt;
	 * &lt;li&gt;an empty {@link MimetypeDetectionBuilder}&lt;/li&gt;
	 * &lt;li&gt;an empty {@link ResourceResolutionBuilder}&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 */
	public MessagingBuilder() {
<span class="fc" id="L254">		super();</span>
<span class="fc" id="L255">		configurers = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L256">		environmentBuilder = new SimpleEnvironmentBuilder&lt;&gt;(this);</span>
<span class="fc" id="L257">		mimetypeBuilder = new SimpleMimetypeDetectionBuilder&lt;&gt;(this, environmentBuilder);</span>
<span class="fc" id="L258">		resourceBuilder = new StandaloneResourceResolutionBuilder&lt;&gt;(this, environmentBuilder);</span>
<span class="fc" id="L259">	}</span>

	/**
	 * Registers a configurer with a priority. Configuration order may be
	 * important. The priority is used to apply configurers in order. The
	 * configurer with highest priority (applied first) has the greatest value.
	 * 
	 * The configurer is applied on a this builder instance to configure it
	 * (when {@link #configure()} is called).
	 * 
	 * &lt;p&gt;
	 * When using {@link #standard()} and {@link #minimal()} factory methods,
	 * the list of configurers are automatically loaded from the classpath and
	 * registered. The priority is indicated through the {@link ConfigurerFor}
	 * annotation.
	 * 
	 * 
	 * @param configurer
	 *            the configurer to register
	 * @param priority
	 *            the configurer priority
	 * @return this instance for fluent chaining
	 */
	public MessagingBuilder register(MessagingConfigurer configurer, int priority) {
<span class="fc" id="L283">		LOG.debug(&quot;[{}] registered with priority={}&quot;, configurer, priority);</span>
<span class="fc" id="L284">		configurers.add(new PrioritizedConfigurer(priority, configurer));</span>
<span class="fc" id="L285">		return this;</span>
	}

	/**
	 * Apply all registered configurers on this builder instance.
	 * 
	 * &lt;p&gt;
	 * When using {@link #standard()} and {@link #minimal()} factory methods,
	 * this method is automatically called.
	 */
	public void configure() {
<span class="fc" id="L296">		Collections.sort(configurers, new PriorityComparator());</span>
<span class="fc bfc" id="L297" title="All 2 branches covered.">		for (PrioritizedConfigurer configurer : configurers) {</span>
<span class="fc" id="L298">			LOG.debug(&quot;[{}] configuring...&quot;, configurer);</span>
<span class="fc" id="L299">			configurer.getConfigurer().configure(this);</span>
<span class="fc" id="L300">		}</span>
<span class="fc" id="L301">	}</span>

	/**
	 * Configures environment for the builder (and sub-builders if inherited).
	 * Environment consists of configuration properties/values that are used to
	 * configure the system (see {@link EnvironmentBuilder} for more
	 * information).
	 * 
	 * You can use system properties:
	 * 
	 * &lt;pre&gt;
	 * .environment()
	 *    .systemProperties();
	 * &lt;/pre&gt;
	 * 
	 * Or, you can load properties from a file:
	 * 
	 * &lt;pre&gt;
	 * .environment()
	 *    .properties(&quot;/path/to/file.properties&quot;)
	 * &lt;/pre&gt;
	 * 
	 * Or using directly a {@link Properties} object:
	 * 
	 * &lt;pre&gt;
	 * Properties myprops = new Properties();
	 * myprops.setProperty(&quot;foo&quot;, &quot;bar&quot;);
	 * .environment()
	 *    .properties(myprops)
	 * &lt;/pre&gt;
	 * 
	 * Or defining directly properties:
	 * 
	 * &lt;pre&gt;
	 * .environment()
	 *    .properties()
	 *       .set(&quot;foo&quot;, &quot;bar&quot;)
	 * &lt;/pre&gt;
	 * 
	 * 
	 * &lt;p&gt;
	 * Every time you are configuring {@link #environment()}, you update the
	 * same instance.
	 * &lt;/p&gt;
	 * 
	 * @return the builder to configure properties handling
	 */
	public EnvironmentBuilder&lt;MessagingBuilder&gt; environment() {
<span class="fc" id="L349">		return environmentBuilder;</span>
	}

	/**
	 * Cconfigures resource resolution.
	 * 
	 * &lt;p&gt;
	 * Resource resolution consists of finding a file:
	 * &lt;ul&gt;
	 * &lt;li&gt;either on filesystem&lt;/li&gt;
	 * &lt;li&gt;or in the classpath&lt;/li&gt;
	 * &lt;li&gt;or anywhere else&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * To identify which resolution to use, each resolution is configured to
	 * handle one or several lookups prefixes. For example, if resolution is
	 * configured like this:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * .string()
	 *   .lookup(&quot;string:&quot;, &quot;s:&quot;)
	 *   .and()
	 * .file()
	 *   .lookup(&quot;file:&quot;)
	 *   .and()
	 * .classpath()
	 *   .lookup(&quot;classpath:&quot;, &quot;&quot;);
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * Then you can reference a file that is in the classpath like this:
	 * 
	 * &lt;pre&gt;
	 * &quot;classpath:foo/bar.html&quot;
	 * &lt;/pre&gt;
	 * 
	 * 
	 * &lt;p&gt;
	 * Resource resolution is also able to handle path prefix and suffix. The
	 * aim is for example to have a folder that contains all templates. The
	 * developer then configures a path prefix for the folder. He can also
	 * configure a suffix to fix extension for templates. Thanks to those
	 * prefix/suffix, templates can now be referenced by the name of the file
	 * (without extension). It is useful to reference a template independently
	 * from where it is in reality (classpath, file or anywhere else) .
	 * Switching from classpath to file and conversely can be done easily (by
	 * updating the lookup).
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * .classpath().lookup(&quot;classpath:&quot;).pathPrefix(&quot;foo/&quot;).pathSuffix(&quot;.html&quot;);
	 * 
	 * resourceResolver.getResource(&quot;classpath:bar&quot;);
	 * &lt;/pre&gt;
	 * 
	 * The real path is then {@code foo/bar.html}.
	 * 
	 * &lt;p&gt;
	 * This implementation is used by {@link MessagingBuilder} for general
	 * configuration. That configuration may be inherited (applied to other
	 * resource resolution builders).
	 * 
	 * @return the builder to configure resource resolution
	 */
	public StandaloneResourceResolutionBuilder&lt;MessagingBuilder&gt; resource() {
<span class="fc" id="L417">		return resourceBuilder;</span>
	}

	/**
	 * Builder that configures mimetype detection.
	 * 
	 * There exists several implementations to provide the mimetype:
	 * &lt;ul&gt;
	 * &lt;li&gt;Using Java {@link MimetypesFileTypeMap}&lt;/li&gt;
	 * &lt;li&gt;Using Java 7 {@link Files#probeContentType(java.nio.file.Path)}&lt;/li&gt;
	 * &lt;li&gt;Using &lt;a href=&quot;http://tika.apache.org/&quot;&gt;Apache Tika&lt;/a&gt;&lt;/li&gt;
	 * &lt;li&gt;Using
	 * &lt;a href=&quot;https://github.com/arimus/jmimemagic&quot;&gt;JMimeMagic&lt;/a&gt;&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * Both implementations provided by Java are based on file extensions. This
	 * can't be used in most cases as we often handle {@link InputStream}s.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * In previous version of Ogham, JMimeMagic was used and was working quite
	 * well. Unfortunately, the library is no more maintained.
	 * &lt;/p&gt;
	 * 
	 * &lt;p&gt;
	 * You can configure how Tika will detect mimetype:
	 * 
	 * &lt;pre&gt;
	 * .mimetype()
	 *    .tika()
	 *       ...
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * This builder allows to use several providers. It will chain them until
	 * one can find a valid mimetype. If none is found, you can explicitly
	 * provide the default one:
	 * 
	 * &lt;pre&gt;
	 * .mimetype()
	 *    .defaultMimetype(&quot;text/html&quot;)
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Every time you are configuring {@link #mimetype()}, the same instance is
	 * used.
	 * &lt;/p&gt;
	 * 
	 * @return the builder to configure mimetype detection
	 */
	public MimetypeDetectionBuilder&lt;MessagingBuilder&gt; mimetype() {
<span class="fc" id="L469">		return mimetypeBuilder;</span>
	}

	/**
	 * There are technical exceptions that are thrown by libraries used by
	 * Ogham. Those exceptions are often {@link RuntimeException}s. It can be
	 * difficult for developers of a big application to quickly identify what
	 * caused this {@link RuntimeException}. The stack trace doesn't always help
	 * to find the real source of the error. If enables, this option ensures
	 * that work done by Ogham will always throw a {@link MessagingException}
	 * even if it was a {@link RuntimeException} thrown by any component. It
	 * then helps the developer to know that the error comes from Ogham or a any
	 * used library and not something else in its application. The other benefit
	 * is that in your code you only catch a {@link MessagingException} and you
	 * are sure that it will handle all cases, no surprise with an unchecked
	 * exception that could make a big failure in your system because you didn't
	 * know this could happen. Sending a message is often not critical (if
	 * message can't be sent now, it can be sent later or manually). It it fails
	 * the whole system must keep on working. With this option enabled, your
	 * system will never fail due to an unchecked exception and you can handle
	 * the failure the same way as with checked exceptions.
	 * 
	 * Concretely, call of
	 * {@link MessagingService#send(fr.sii.ogham.core.message.Message)} catches
	 * all exceptions including {@link RuntimeException}. It wraps any
	 * exceptions into a {@link MessagingException}.
	 * 
	 * @param enable
	 *            enable or disable wrapping of exceptions
	 * @return this instance for fluent chaining
	 */
	public MessagingBuilder wrapUncaught(boolean enable) {
<span class="fc" id="L501">		wrapUncaught = enable;</span>
<span class="fc" id="L502">		return this;</span>
	}

	/**
	 * Configures how to send {@link Email} messages. It allows to:
	 * &lt;ul&gt;
	 * &lt;li&gt;register and configure several sender implementations&lt;/li&gt;
	 * &lt;li&gt;register and configure several template engines for parsing templates
	 * as message content&lt;/li&gt;
	 * &lt;li&gt;configure handling of missing {@link Email} information&lt;/li&gt;
	 * &lt;li&gt;configure handling of file attachments&lt;/li&gt;
	 * &lt;li&gt;configure CSS and image handling for {@link Email}s with an HTML
	 * body&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * You can send an {@link Email} using the minimal behavior and using
	 * JavaMail implementation:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .email()
	 *     .sender(JavaMailBuilder.class)   // enable Email sending using JavaMail
	 *       .host(&quot;your SMTP server host&quot;)
	 *       .port(&quot;your SMTP server port&quot;)
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email
	 * service.send(new Email()
	 *   .from(&quot;sender email address&quot;)
	 *   .subject(&quot;email subject&quot;)
	 *   .content(&quot;email body&quot;)
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * You can also send an {@link Email} using a template (using Freemarker for
	 * example):
	 * 
	 * The Freemarker template (&quot;email/sample.html.ftl&quot;):
	 * 
	 * &lt;pre&gt;
	 * &amp;lt;html&amp;gt;
	 * &amp;lt;head&amp;gt;
	 * &amp;lt;/head&amp;gt;
	 * &amp;lt;body&amp;gt;
	 * Email content with variables: ${name} ${value}
	 * &amp;lt;/body&amp;gt;
	 * &amp;lt;/html&amp;gt;
	 * &lt;/pre&gt;
	 * 
	 * Then you can send the {@link Email} like this:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .email()
	 *     .sender(JavaMailBuilder.class)   // enable Email sending using JavaMail
	 *       .host(&quot;your SMTP server host&quot;)
	 *       .port(&quot;your SMTP server port&quot;)
	 *       .and()
	 *     .and()
	 *   .template(FreemarkerEmailBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email
	 * service.send(new Email()
	 *   .from(&quot;sender email address&quot;)
	 *   .subject(&quot;email subject&quot;)
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Instead of explicitly configures SMTP host and port in your code, it
	 * could be better to externalize the configuration in a properties file for
	 * example (for example a file named &quot;email.properties&quot; in the classpath).
	 * The previous example becomes:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;email.properties&quot;)
	 *     .and()
	 *   .email()
	 *     .sender(JavaMailBuilder.class)   // enable Email sending using JavaMail
	 *       .host(&quot;${mail.host}&quot;)
	 *       .port(&quot;${mail.port}&quot;)
	 *       .and()
	 *     .and()
	 *   .template(FreemarkerEmailBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email
	 * service.send(new Email()
	 *   .from(&quot;sender email address&quot;)
	 *   .subject(&quot;email subject&quot;)
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The content of the file &quot;email.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * mail.host=your STMP server host
	 * mail.port=your STMP server port
	 * &lt;/pre&gt;
	 * 
	 * 
	 * Some fields of the Email may be automatically filled by a default value
	 * if they are not defined. For example, the sender address could be
	 * configured only once for your application:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;email.properties&quot;)
	 *     .and()
	 *   .email()
	 *     .sender(JavaMailBuilder.class)   // enable Email sending using JavaMail
	 *       .host(&quot;${mail.host}&quot;)
	 *       .port(&quot;${mail.port}&quot;)
	 *       .and()
	 *     .autofill()    // enables and configures autofilling
	 *       .from()
	 *         .defaultValueProperty(&quot;${email.sender.address}&quot;)
	 *         .and()
	 *     .and()
	 *   .template(FreemarkerEmailBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email (now the sender address can be omitted)
	 * service.send(new Email()
	 *   .subject(&quot;email subject&quot;)
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The content of the file &quot;email.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * mail.host=your STMP server host
	 * mail.port=your STMP server port
	 * email.sender.address=sender email address
	 * &lt;/pre&gt;
	 * 
	 * 
	 * 
	 * Another very useful automatic filling is for providing the email subject:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;email.properties&quot;)
	 *     .and()
	 *   .email()
	 *     .sender(JavaMailBuilder.class)   // enable Email sending using JavaMail
	 *       .host(&quot;${mail.host}&quot;)
	 *       .port(&quot;${mail.port}&quot;)
	 *       .and()
	 *     .autofill()    // enables and configures autofilling
	 *       .from()
	 *         .defaultValueProperty(&quot;${email.sender.address}&quot;)
	 *         .and()
	 *       .subject()
	 *         .htmlTitle(true)    // enables use of html title tag as subject
	 *     .and()
	 *   .template(FreemarkerEmailBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email (now the subject can be omitted)
	 * service.send(new Email()
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * Change your template:
	 * 
	 * &lt;pre&gt;
	 * &amp;lt;html&amp;gt;
	 * &amp;lt;head&amp;gt;
	 *   &amp;lt;title&amp;gt;email subject - ${name}&amp;lt;/title&amp;gt;
	 * &amp;lt;/head&amp;gt;
	 * &amp;lt;body&amp;gt;
	 * Email content with variables: ${name} ${value}
	 * &amp;lt;/body&amp;gt;
	 * &amp;lt;/html&amp;gt;
	 * &lt;/pre&gt;
	 * 
	 * The obvious advantage is that you have a single place to handle email
	 * content (body + subject). There is another benefit: you can also use
	 * variables in the subject.
	 * 
	 * 
	 * There many other configuration possibilities:
	 * &lt;ul&gt;
	 * &lt;li&gt;for configuring {@link Email}s with HTML content with a text fallback
	 * (useful for smartphones preview of your email for example)&lt;/li&gt;
	 * &lt;li&gt;for configuring attachments handling&lt;/li&gt;
	 * &lt;li&gt;for configuring image and css handling&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * All the previous examples are provided to understand what can be
	 * configured. Hopefully, Ogham provides auto-configuration with a default
	 * behavior that fits 95% of usages. This auto-configuration is provided by
	 * {@link MessagingConfigurer}s. Those configurers are automatically applied
	 * when using predefined {@link MessagingBuilder}s like
	 * {@link MessagingBuilder#minimal()} and
	 * {@link MessagingBuilder#standard()}.
	 * 
	 * The previous sample using standard configuration becomes:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;email.properties&quot;)
	 *     .and()
	 *   .build();
	 * // send the email
	 * service.send(new Email()
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The new content of the file &quot;email.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * mail.host=your STMP server host
	 * mail.port=your STMP server port
	 * ogham.email.from=sender email address
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * You can also use the auto-configuration for benefit from default
	 * behaviors and override some behaviors for your needs:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;email.properties&quot;)
	 *     .and()
	 *   .email()
	 *     .autofill()
	 *       .from()
	 *         .defaultValueProperty(&quot;${email.sender.address}&quot;)   // overrides default sender email address property
	 *         .and()
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the email
	 * service.send(new Email()
	 *   .content(new TemplateContent(&quot;classpath:email/sample.html.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient email address&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The new content of the file &quot;email.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * mail.host=your STMP server host
	 * mail.port=your STMP server port
	 * email.sender.address=sender email address
	 * &lt;/pre&gt;
	 * 
	 * 
	 * @return the builder to configure how Email are handled
	 */
	public EmailBuilder email() {
<span class="fc bfc" id="L801" title="All 2 branches covered.">		if (emailBuilder == null) {</span>
<span class="fc" id="L802">			emailBuilder = new EmailBuilder(this, environmentBuilder);</span>
		}
<span class="fc" id="L804">		return emailBuilder;</span>
	}

	/**
	 * Configures how to send {@link Sms} messages. It allows to:
	 * &lt;ul&gt;
	 * &lt;li&gt;register and configure several sender implementations&lt;/li&gt;
	 * &lt;li&gt;register and configure several template engines for parsing templates
	 * as message content&lt;/li&gt;
	 * &lt;li&gt;configure handling of missing {@link Sms} information&lt;/li&gt;
	 * &lt;li&gt;configure number format handling&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * You can send a {@link Sms} using the minimal behavior and using
	 * Cloudhopper implementation:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .sms()
	 *     .sender(CloudhopperBuilder.class)   // enable SMS sending using Cloudhopper
	 *       .host(&quot;your SMPP server host&quot;)
	 *       .port(&quot;your SMPP server port&quot;)
	 *       .systemId(&quot;your SMPP system_id&quot;)
	 *       .password(&quot;an optional password&quot;)
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the sms
	 * service.send(new Sms()
	 *   .from(&quot;sender phone number&quot;)
	 *   .content(&quot;sms content&quot;)
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * You can also send a {@link Sms} using a template (using Freemarker for
	 * example):
	 * 
	 * The Freemarker template (&quot;sms/sample.txt.ftl&quot;):
	 * 
	 * &lt;pre&gt;
	 * Sms content with variables: ${name} ${value}
	 * &lt;/pre&gt;
	 * 
	 * Then you can send the {@link Sms} like this:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .sms()
	 *     .sender(CloudhopperBuilder.class)   // enable SMS sending using Cloudhopper
	 *       .host(&quot;your SMPP server host&quot;)
	 *       .port(&quot;your SMPP server port&quot;)
	 *       .systemId(&quot;your SMPP system_id&quot;)
	 *       .password(&quot;an optional password&quot;)
	 *       .and()
	 *     .and()
	 *   .template(FreemarkerSmsBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the sms
	 * service.send(new Sms()
	 *   .from(&quot;sender phone number&quot;)
	 *   .content(new TemplateContent(&quot;classpath:sms/sample.txt.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Instead of explicitly configures SMPP host/port/system_id/password in
	 * your code, it could be better to externalize the configuration in a
	 * properties file for example (for example a file named &quot;sms.properties&quot; in
	 * the classpath). The previous example becomes:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;sms.properties&quot;)
	 *     .and()
	 *   .sms()
	 *     .sender(CloudhopperBuilder.class)   // enable SMS sending using Cloudhopper
	 *       .host(&quot;${smpp.host}&quot;)
	 *       .port(&quot;${smpp.port}&quot;)
	 *       .systemId(&quot;${smpp.system-id}&quot;)
	 *       .password(&quot;${smpp.password}&quot;)
	 *       .and()
	 *     .and()
	 *   .template(FreemarkerSmsBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the sms
	 * service.send(new Sms()
	 *   .from(&quot;sender phone number&quot;)
	 *   .content(new TemplateContent(&quot;classpath:sms/sample.txt.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The content of the file &quot;sms.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * smpp.host=your SMPP server host
	 * smpp.port=your SMPP server port
	 * smpp.system-id=your SMPP system_id
	 * smpp.password=an optional password
	 * &lt;/pre&gt;
	 * 
	 * 
	 * Some fields of the SMS may be automatically filled by a default value if
	 * they are not defined. For example, the sender phone number could be
	 * configured only once for your application:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = new MessagingBuilder()
	 *   .environment()
	 *     .properties(&quot;sms.properties&quot;)
	 *     .and()
	 *   .sms()
	 *     .sender(CloudhopperBuilder.class)   // enable SMS sending using Cloudhopper
	 *       .host(&quot;${smpp.host}&quot;)
	 *       .port(&quot;${smpp.port}&quot;)
	 *       .systemId(&quot;${smpp.system-id}&quot;)
	 *       .password(&quot;${smpp.password}&quot;)
	 *       .and()
	 *     .autofill()    // enables and configures autofilling
	 *       .from()
	 *         .defaultValueProperty(&quot;${sms.sender.number}&quot;)
	 *         .and()
	 *       .and()
	 *     .and()
	 *   .template(FreemarkerSmsBuilder.class)  // enable templating using Freemarker
	 *     .classpath()
	 *       .lookup(&quot;classpath:&quot;)   // search resources/templates in the classpath if a path is prefixed by &quot;classpath:&quot;
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the sms (now the sender phone number can be omitted)
	 * service.send(new Sms()
	 *   .content(new TemplateContent(&quot;classpath:sms/sample.txt.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The new content of the file &quot;sms.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * smpp.host=your SMPP server host
	 * smpp.port=your SMPP server port
	 * smpp.system-id=your SMPP system_id
	 * smpp.password=an optional password
	 * sms.sender.number=the sender phone number
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * All the previous examples are provided to understand what can be
	 * configured. Hopefully, Ogham provides auto-configuration with a default
	 * behavior that fits 95% of usages. This auto-configuration is provided by
	 * {@link MessagingConfigurer}s. Those configurers are automatically applied
	 * when using predefined {@link MessagingBuilder}s like
	 * {@link MessagingBuilder#minimal()} and
	 * {@link MessagingBuilder#standard()}.
	 * 
	 * The previous sample using standard configuration becomes:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;sms.properties&quot;)
	 *     .and()
	 *   .build();
	 * // send the sms
	 * service.send(new Sms()
	 *   .content(new TemplateContent(&quot;classpath:sms/sample.txt.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The new content of the file &quot;sms.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * ogham.sms.smpp.host=your SMPP server host
	 * ogham.sms.smpp.port=your SMPP server port
	 * ogham.sms.smpp.system-id=your SMPP system_id
	 * ogham.sms.smpp.password=an optional password
	 * ogham.sms.from=the sender phone number
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * You can also use the auto-configuration for benefit from default
	 * behaviors and override some behaviors for your needs:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * // Instantiate the messaging service
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;sms.properties&quot;)
	 *     .and()
	 *   .sms()
	 *     .autofill()
	 *       .from()
	 *         .defaultValueProperty(&quot;${sms.sender.number}&quot;)   // overrides default sender phone number property
	 *         .and()
	 *       .and()
	 *     .and()
	 *   .build();
	 * // send the sms
	 * service.send(new Sms()
	 *   .content(new TemplateContent(&quot;classpath:sms/sample.txt.ftl&quot;, new SampleBean(&quot;foo&quot;, 42)))
	 *   .to(&quot;recipient phone number&quot;));
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * The new content of the file &quot;sms.properties&quot;:
	 * 
	 * &lt;pre&gt;
	 * ogham.sms.smpp.host=your SMPP server host
	 * ogham.sms.smpp.port=your SMPP server port
	 * ogham.sms.smpp.system-id=your SMPP system_id
	 * ogham.sms.smpp.password=an optional password
	 * sms.sender.number=the sender phone number
	 * &lt;/pre&gt;
	 * 
	 * @return the builder to configure how SMS are handled
	 */
	public SmsBuilder sms() {
<span class="fc bfc" id="L1045" title="All 2 branches covered.">		if (smsBuilder == null) {</span>
<span class="fc" id="L1046">			smsBuilder = new SmsBuilder(this, environmentBuilder);</span>
		}
<span class="fc" id="L1048">		return smsBuilder;</span>
	}

	/**
	 * Builds the messaging service. The messaging service relies on the
	 * generated senders. Each sender is able to manage one or multiple
	 * messages. The default implementation of the messaging service is to ask
	 * each sender if it is able to handle the message and if it the case, then
	 * use this sender to really send the message. This implementation doesn't
	 * stop when the message is handled by a sender to possibly let another send
	 * the message through another channel.
	 * 
	 * &lt;p&gt;
	 * If a {@link RuntimeException} is thrown while trying to send a message,
	 * the service will catch it and wrap it into a {@link MessagingException}
	 * in order to indicate that the exception was caused while trying to send a
	 * message.
	 * &lt;/p&gt;
	 * 
	 * @return the messaging service instance
	 * @throws BuildException
	 *             when service couldn't be instantiated and configured
	 */
	@Override
	public MessagingService build() {
<span class="fc" id="L1073">		LOG.info(&quot;Using service that calls all registered senders&quot;);</span>
<span class="fc" id="L1074">		List&lt;ConditionalSender&gt; senders = buildSenders();</span>
<span class="fc" id="L1075">		LOG.debug(&quot;Registered senders: {}&quot;, senders);</span>
<span class="fc" id="L1076">		MessagingService service = new EverySupportingMessagingService(senders);</span>
<span class="fc bfc" id="L1077" title="All 2 branches covered.">		if (wrapUncaught) {</span>
<span class="fc" id="L1078">			service = new WrapExceptionMessagingService(service);</span>
		}
<span class="fc" id="L1080">		return service;</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance with no auto-configuration at all.
	 * 
	 * @return the empty builder that provides no behavior at all that needs to
	 *         be configured
	 */
	public static MessagingBuilder empty() {
<span class="fc" id="L1091">		return new MessagingBuilder();</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and auto-configures it with a predefined behavior named
	 * &quot;standard&quot;.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the standard behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Email} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Sms} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in &quot;fr.sii.ogham&quot;
	 * package and sub-packages are loaded. If you want to load from other
	 * packages, use {@link #standard(String...)}. Some Ogham modules are
	 * optional meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;standard&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;standard&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultJavaMailConfigurer&lt;/code&gt;: 50000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultCloudhopperConfigurer&lt;/code&gt;: 40000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultSendGridConfigurer&lt;/code&gt;: 30000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultOvhSmsConfigurer&lt;/code&gt;: 20000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by standard
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior that fits 95% of usages. You can still override some behaviors
	 * for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder standard() {
<span class="fc" id="L1183">		return standard(BASE_PACKAGE);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and auto-configures it with a predefined behavior named
	 * &quot;standard&quot;.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the standard behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Email} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Sms} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in the provided
	 * packages and sub-packages are loaded. Some Ogham modules are optional
	 * meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;standard&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;standard&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultJavaMailConfigurer&lt;/code&gt;: 50000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultCloudhopperConfigurer&lt;/code&gt;: 40000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultSendGridConfigurer&lt;/code&gt;: 30000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultOvhSmsConfigurer&lt;/code&gt;: 20000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by standard
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior that fits 95% of usages. You can still override some behaviors
	 * for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param basePackages
	 *            the base packages that are scanned to find
	 *            {@link MessagingConfigurer} implementations
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder standard(String... basePackages) {
<span class="fc" id="L1277">		return standard(true, basePackages);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and registers auto-configures but doesn't apply them if
	 * autoconfigure parameter is false. The {@link #configure()} method must be
	 * called manually.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the standard behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Email} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Sms} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in &quot;fr.sii.ogham&quot;
	 * package and sub-packages are loaded. If you want to load from other
	 * packages, use {@link #standard(String...)}. Some Ogham modules are
	 * optional meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;standard&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;standard&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultJavaMailConfigurer&lt;/code&gt;: 50000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultCloudhopperConfigurer&lt;/code&gt;: 40000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultSendGridConfigurer&lt;/code&gt;: 30000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultOvhSmsConfigurer&lt;/code&gt;: 20000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by standard
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior that fits 95% of usages. You can still override some behaviors
	 * for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param autoconfigure
	 *            true to automatically apply found configurers, false to
	 *            configure manually later by calling {@link #configure()}
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder standard(boolean autoconfigure) {
<span class="fc" id="L1373">		return standard(autoconfigure, BASE_PACKAGE);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and registers auto-configures but doesn't apply them if
	 * autoconfigure parameter is false. The {@link #configure()} method must be
	 * called manually.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the standard behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Email} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Enables all {@link Sms} sender implementations that are present in
	 * the classpath and configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in the provided
	 * packages and sub-packages are loaded. Some Ogham modules are optional
	 * meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;standard&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;standard&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultJavaMailConfigurer&lt;/code&gt;: 50000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultCloudhopperConfigurer&lt;/code&gt;: 40000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultSendGridConfigurer&lt;/code&gt;: 30000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultOvhSmsConfigurer&lt;/code&gt;: 20000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by standard
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior that fits 95% of usages. You can still override some behaviors
	 * for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.standard()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param autoconfigure
	 *            true to automatically apply found configurers, false to
	 *            configure manually later by calling {@link #configure()}
	 * @param basePackages
	 *            the base packages that are scanned to find
	 *            {@link MessagingConfigurer} implementations
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder standard(boolean autoconfigure, String... basePackages) {
<span class="fc" id="L1471">		MessagingBuilder builder = new MessagingBuilder();</span>
<span class="fc" id="L1472">		findAndRegister(builder, &quot;standard&quot;, basePackages);</span>
<span class="fc bfc" id="L1473" title="All 2 branches covered.">		if (autoconfigure) {</span>
<span class="fc" id="L1474">			builder.configure();</span>
		}
<span class="fc" id="L1476">		return builder;</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and auto-configures it with a predefined behavior named
	 * &quot;minimal&quot;.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the minimal behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The minimal behavior doesn't automatically auto-configure sender
	 * implementations.
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in &quot;fr.sii.ogham&quot;
	 * package and sub-packages are loaded. If you want to load from other
	 * packages, use {@link #minimal(String...)}. Some Ogham modules are
	 * optional meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;minimal&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;minimal&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by minimal
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior with no sender implementation. This is useful if you only want
	 * to use a particular implementation or your custom sender implementation.
	 * You can still override some behaviors for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder minimal() {
<span class="nc" id="L1564">		return minimal(BASE_PACKAGE);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and auto-configures it with a predefined behavior named
	 * &quot;minimal&quot;.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the minimal behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The minimal behavior doesn't automatically auto-configure sender
	 * implementations.
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in the provided
	 * packages and sub-packages are loaded. Some Ogham modules are optional
	 * meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;minimal&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;minimal&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by minimal
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior with no sender implementation. This is useful if you only want
	 * to use a particular implementation or your custom sender implementation.
	 * You can still override some behaviors for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param basePackages
	 *            the base packages that are scanned to find
	 *            {@link MessagingConfigurer} implementations
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder minimal(String... basePackages) {
<span class="nc" id="L1654">		return minimal(true, basePackages);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and registers auto-configures but doesn't apply them if
	 * autoconfigure parameter is false. The {@link #configure()} method must be
	 * called manually.
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the minimal behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The minimal behavior doesn't automatically auto-configure sender
	 * implementations.
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in &quot;fr.sii.ogham&quot;
	 * package and sub-packages are loaded. If you want to load from other
	 * packages, use {@link #minimal(String...)}. Some Ogham modules are
	 * optional meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;minimal&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;minimal&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by minimal
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior with no sender implementation. This is useful if you only want
	 * to use a particular implementation or your custom sender implementation.
	 * You can still override some behaviors for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param autoconfigure
	 *            true to automatically apply found configurers, false to
	 *            configure manually later by calling {@link #configure()}
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder minimal(boolean autoconfigure) {
<span class="nc" id="L1746">		return minimal(autoconfigure, BASE_PACKAGE);</span>
	}

	/**
	 * Static factory method that initializes a {@link MessagingBuilder}
	 * instance and registers auto-configures but doesn't apply them if
	 * autoconfigure parameter is false. The {@link #configure()} method must be
	 * called manually.
	 * 
	 * 
	 * Usage example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * &lt;p&gt;
	 * Basically, the minimal behavior:
	 * &lt;ul&gt;
	 * &lt;li&gt;Enables all template engines that are present in the classpath and
	 * configures them&lt;/li&gt;
	 * &lt;li&gt;Catches all uncaught exception to wrap them in order to avoid
	 * unwanted unchecked exception&lt;/li&gt;
	 * &lt;li&gt;Uses system properties&lt;/li&gt;
	 * &lt;li&gt;Enables and configures useful auto-filling mechanisms (using property
	 * values and providing email subject from templates)&lt;/li&gt;
	 * &lt;li&gt;Enables mimetype detection&lt;/li&gt;
	 * &lt;li&gt;Enables locating templates, css, images and all other resources using
	 * lookup prefix (&quot;file:&quot; for files that are present on the filesystem,
	 * &quot;classpath:&quot; and &quot;&quot; for files that are present in the classpath)&lt;/li&gt;
	 * &lt;li&gt;Enables use of some properties to provide path prefix/suffix for
	 * locating resources&lt;/li&gt;
	 * &lt;li&gt;Enables images and css inlining used by HTML {@link Email}s&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * The minimal behavior doesn't automatically auto-configure sender
	 * implementations.
	 * 
	 * &lt;p&gt;
	 * The auto-configurers ( {@link MessagingConfigurer}s) are automatically
	 * loaded from the classpath. Only configurers that are in the provided
	 * packages and sub-packages are loaded. Some Ogham modules are optional
	 * meaning that according to used modules, the behavior will vary.
	 * 
	 * Loaded {@link MessagingConfigurer}s are applied to the
	 * {@link MessagingBuilder} only if they are for the &quot;minimal&quot; builder. It
	 * is accomplished thanks to the {@link ConfigurerFor} annotation (only
	 * configurers annotated and with {@link ConfigurerFor#targetedBuilder()}
	 * set to &quot;minimal&quot;).
	 * 
	 * Loaded configurers with priorities are (if all Ogham modules are used):
	 * &lt;ul&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultMessagingConfigurer&lt;/code&gt;: 100000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafEmailConfigurer&lt;/code&gt;: 90000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerEmailConfigurer&lt;/code&gt;: 80000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultThymeleafSmsConfigurer&lt;/code&gt;: 70000&lt;/li&gt;
	 * &lt;li&gt;&lt;code&gt;DefaultFreemarkerSmsConfigurer&lt;/code&gt;: 60000&lt;/li&gt;
	 * &lt;/ul&gt;
	 * 
	 * TODO: link to whole configuration that is applied by minimal
	 * 
	 * &lt;p&gt;
	 * The auto-configured {@link MessagingBuilder} will provide a default
	 * behavior with no sender implementation. This is useful if you only want
	 * to use a particular implementation or your custom sender implementation.
	 * You can still override some behaviors for your needs.
	 * 
	 * For example:
	 * 
	 * &lt;pre&gt;
	 * &lt;code&gt;
	 * MessagingService service = MessagingBuilder.minimal()
	 *   .environment()
	 *     .properties(&quot;application.properties&quot;)
	 *     .and()
	 *   .wrapUncaught(false)    // overrides and disables wrapUncaught option
	 *   .build();
	 * &lt;/code&gt;
	 * &lt;/pre&gt;
	 * 
	 * @param autoconfigure
	 *            true to automatically apply found configurers, false to
	 *            configure manually later by calling {@link #configure()}
	 * @param basePackages
	 *            the base packages that are scanned to find
	 *            {@link MessagingConfigurer} implementations
	 * @return the messaging builder that can be customized
	 */
	public static MessagingBuilder minimal(boolean autoconfigure, String... basePackages) {
<span class="nc" id="L1841">		MessagingBuilder builder = new MessagingBuilder();</span>
<span class="nc" id="L1842">		findAndRegister(builder, &quot;minimal&quot;, basePackages);</span>
<span class="nc bnc" id="L1843" title="All 2 branches missed.">		if (autoconfigure) {</span>
<span class="nc" id="L1844">			builder.configure();</span>
		}
<span class="nc" id="L1846">		return builder;</span>
	}

	/**
	 * You can use this method if {@link #standard()} and {@link #minimal()}
	 * factory methods doesn't fit your needs. The aim is to auto-configure a
	 * builder with matching configurers.
	 * 
	 * Utility method that searches all {@link MessagingConfigurer}s that are in
	 * the classpath. Only configurers that are in the provided packages (and
	 * sub-packages) are loaded.
	 * 
	 * Once configurers are found, they are filtered thanks to information
	 * provided by {@link ConfigurerFor} annotation. Only configurers with
	 * {@link ConfigurerFor#targetedBuilder()} value that matches the
	 * builderName parameter are kept.
	 * 
	 * The found and filtered configurers are registered into the provided
	 * builder instance.
	 * 
	 * @param builder
	 *            the builder to configure with matching configurers
	 * @param builderName
	 *            the name that is referenced by
	 *            {@link ConfigurerFor#targetedBuilder()}
	 * @param basePackages
	 *            the packages that are scanned to find
	 *            {@link MessagingConfigurer} implementations
	 */
	public static void findAndRegister(MessagingBuilder builder, String builderName, String... basePackages) {
<span class="fc" id="L1876">		Reflections reflections = new Reflections(basePackages, new SubTypesScanner());</span>
<span class="fc" id="L1877">		Set&lt;Class&lt;? extends MessagingConfigurer&gt;&gt; configurerClasses = reflections.getSubTypesOf(MessagingConfigurer.class);</span>
<span class="fc bfc" id="L1878" title="All 2 branches covered.">		for (Class&lt;? extends MessagingConfigurer&gt; configurerClass : configurerClasses) {</span>
<span class="fc" id="L1879">			ConfigurerFor annotation = configurerClass.getAnnotation(ConfigurerFor.class);</span>
<span class="pc bpc" id="L1880" title="1 of 4 branches missed.">			if (annotation != null &amp;&amp; asList(annotation.targetedBuilder()).contains(builderName)) {</span>
				try {
<span class="fc" id="L1882">					builder.register(configurerClass.newInstance(), annotation.priority());</span>
<span class="nc" id="L1883">				} catch (InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L1884">					throw new BuildException(&quot;Failed to register custom auto-discovered configurer (&quot; + configurerClass.getSimpleName() + &quot;) for standard messaging builder&quot;, e);</span>
<span class="fc" id="L1885">				}</span>
			}
<span class="fc" id="L1887">		}</span>
<span class="fc" id="L1888">	}</span>

	private List&lt;ConditionalSender&gt; buildSenders() {
<span class="fc" id="L1891">		List&lt;ConditionalSender&gt; senders = new ArrayList&lt;&gt;();</span>
<span class="pc bpc" id="L1892" title="1 of 2 branches missed.">		if (emailBuilder != null) {</span>
<span class="fc" id="L1893">			LOG.debug(&quot;building email sender with {}&quot;, emailBuilder);</span>
<span class="fc" id="L1894">			senders.add(emailBuilder.build());</span>
		}
<span class="fc bfc" id="L1896" title="All 2 branches covered.">		if (smsBuilder != null) {</span>
<span class="fc" id="L1897">			LOG.debug(&quot;building email sender with {}&quot;, emailBuilder);</span>
<span class="fc" id="L1898">			senders.add(smsBuilder.build());</span>
		}
<span class="fc" id="L1900">		return senders;</span>
	}

	private static class PriorityComparator implements Comparator&lt;PrioritizedConfigurer&gt; {
		@Override
		public int compare(PrioritizedConfigurer o1, PrioritizedConfigurer o2) {
<span class="fc" id="L1906">			return -Integer.compare(o1.getPriority(), o2.getPriority());</span>
		}
	}

	private static class PrioritizedConfigurer {
		private final int priority;
		private final MessagingConfigurer configurer;

		public PrioritizedConfigurer(int priority, MessagingConfigurer configurer) {
<span class="fc" id="L1915">			super();</span>
<span class="fc" id="L1916">			this.priority = priority;</span>
<span class="fc" id="L1917">			this.configurer = configurer;</span>
<span class="fc" id="L1918">		}</span>

		public int getPriority() {
<span class="fc" id="L1921">			return priority;</span>
		}

		public MessagingConfigurer getConfigurer() {
<span class="fc" id="L1925">			return configurer;</span>
		}

		@Override
		public String toString() {
<span class="fc" id="L1930">			return configurer.toString();</span>
		}
	}

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.4.201905082037</span></div></body></html>